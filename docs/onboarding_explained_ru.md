# Подробное объяснение текущего этапа и как работать дальше

Ниже — ответы на твои вопросы максимально простым языком.

## 1) Что уже сделано на текущем этапе

Коротко: **сделана стартовая база проекта (каркас), но не финальный продукт**.

Что именно есть сейчас:

- структура репозитория под все части: backend, frontend, bot, worker;
- базовый `docker-compose.yml` (пока только БД + backend);
- `.env.example` с переменными окружения;
- backend на FastAPI с двумя обязательными endpoint'ами из ТЗ:
  - `POST /api/login` (получение JWT),
  - `GET /api/cars` (защищённый endpoint);
- в backend пока используются **тестовые in-memory данные**, а не настоящая БД-логика;
- план выполнения на 2–3 дня.

Что **ещё не реализовано**:

- полноценные SQLAlchemy-модели и реальная работа с PostgreSQL;
- Alembic-миграции и сидинг админа через БД;
- воркер парсинга carsensor.net с upsert/retry;
- frontend (login + таблица);
- Telegram-бот с Function Calling LLM.

Итого: это хороший старт, чтобы быстро двигаться по дедлайну, но не финал.

---

## 2) Можно ли работать только со мной или нужно клонить репозиторий и открыть VS Code

Лучший практический вариант:

- **ты + я как «пилот и штурман»** (я даю код, шаги, объяснения, проверочные команды);
- **репозиторий у тебя локально** (или на сервере), в IDE (VS Code / PyCharm) — чтобы ты видел, запускал и понимал каждый шаг.

Почему лучше клонить себе:

- ты контролируешь финальную сдачу;
- можешь сам запускать Docker, смотреть логи, дебажить;
- можно быстро править и проверять UI/бота локально;
- при собеседовании тебе будет легче объяснить, что и как работает.

Рекомендация: да, **клонировать обязательно** и работать через IDE, а меня использовать как ускоритель и ментора.

---

## 3) Чем будет являться конечный продукт

Финальный результат по ТЗ — это **готовый mini-production сервис** из 4 частей:

1. **Backend API**
   - авторизация (`/api/login`, JWT),
   - защищённый список авто (`/api/cars`),
   - данные хранятся в PostgreSQL.

2. **Скрапер/воркер**
   - периодически читает объявления из carsensor.net,
   - приводит поля к нужному виду,
   - делает upsert (обновляет существующие + вставляет новые),
   - имеет retry на сетевых ошибках.

3. **Frontend SPA**
   - `/login`: вход,
   - `/`: таблица авто,
   - JWT хранится и используется для API-запросов.

4. **Telegram-бот**
   - принимает свободный текст,
   - через Function Calling вытаскивает фильтры,
   - делает SQL-запрос,
   - отдаёт понятный ответ.

Плюс обязательная «упаковка»:

- запуск одной командой: `docker compose up --build`;
- `.env.example`;
- README с инструкцией, архитектурой, логином/паролем.

---

## 4) Какие дальнейшие шаги (практический порядок)

Ниже наиболее безопасная и быстрая последовательность под дедлайн:

### Шаг A (сегодня): backend сделать «настоящим»

- подключить SQLAlchemy + PostgreSQL;
- создать модели `users` и `cars`;
- подключить Alembic, сделать миграцию;
- сидинг админа;
- переписать login/cars на БД.

### Шаг B: воркер

- клиент для carsensor API;
- маппинг в поля БД;
- upsert;
- retry/backoff;
- периодический цикл.

### Шаг C: frontend

- форма логина;
- защищённый роут;
- таблица с автомобилями;
- обработка 401 и истечения токена.

### Шаг D: Telegram-бот

- aiogram;
- schema для function calling;
- трансляция фильтров в SQL;
- красивый текст ответа.

### Шаг E: сдача

- docker compose smoke-test;
- README финализировать;
- проверить переменные и секреты;
- сделать демо-сценарий на 3–5 минут.

---

## 5) Подробно: PostgreSQL, Docker, Alembic, JWT

## PostgreSQL (Postgres)

Это реляционная СУБД (как «хранилище таблиц»).

В нашем проекте там будут, например:

- `users` (админ и, при желании, другие пользователи),
- `cars` (объявления).

Почему это важно:

- данные сохраняются между перезапусками;
- можно делать фильтры/сортировки SQL-запросами;
- легко делать upsert и индексы.

Пример пользы для нас: при новом проходе воркера мы не «дублируем» все машины, а обновляем существующие по ключу (например, по ссылке объявления).

## Docker

Docker упаковывает каждый сервис в отдельный контейнер.

У нас:

- контейнер БД,
- контейнер backend,
- позже контейнеры frontend/worker/bot.

Плюс:

- одинаковый запуск у всех (`docker compose up --build`),
- не нужно вручную ставить кучу зависимостей на хост,
- проще сдача тестового.

## Alembic

Alembic — это миграции схемы БД для SQLAlchemy.

Проще: это «история изменений таблиц».

Например:

- создали `users` и `cars` (миграция 001),
- добавили индекс в `cars` (миграция 002),
- поменяли тип поля (миграция 003).

Почему критично:

- можно воспроизводимо поднять структуру БД с нуля;
- изменения схемы контролируются в git;
- на дедлайне меньше риска «у меня работает, у проверяющего нет».

## JWT

JWT (JSON Web Token) — это токен авторизации.

Как поток выглядит у нас:

1. Клиент отправляет логин/пароль на `/api/login`.
2. Сервер проверяет и выдаёт JWT.
3. Клиент кладёт токен в `Authorization: Bearer <token>`.
4. Сервер на защищённых endpoint’ах проверяет токен.

Почему удобно:

- backend не хранит сессии в памяти;
- легко использовать в SPA и Telegram-интеграциях;
- стандартный и ожидаемый для тестовых API-проектов.

---

## Как работать со мной максимально эффективно

Формула работы:

1. Ты пишешь, какой блок делаем сейчас (например: «делаем Alembic + модели»).
2. Я даю:
   - пошаговый план,
   - конкретные файлы/изменения,
   - команды запуска/проверки,
   - что должно получиться в итоге.
3. Ты запускаешь у себя и присылаешь ошибки/логи.
4. Я быстро разбираю и даю точный фикс.
5. После каждого блока делаем маленький коммит.

Лучший формат запросов ко мне:

- «Сделай минимальную рабочую версию X»
- «Объясни это как новичку и приведи команды»
- «Вот лог ошибки, что править?»

Если хочешь, я дальше могу вести тебя в режиме **жёсткого тайм-менеджмента**:

- даю задачи на 60–90 минут,
- в конце каждого блока — чек-лист готовности,
- сразу фиксируем прогресс для дедлайна.
